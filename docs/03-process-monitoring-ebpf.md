# 任务 03: 进程监控 eBPF 程序实现

## 任务目标

实现完整的进程生命周期监控 eBPF 程序,包括进程创建、执行、退出事件的捕获,以及相关系统信息的收集,输出结构化的 JSON 格式数据。

## 前置条件

- **任务 01** 已完成(环境搭建)
- **任务 02** 已完成(eBPF 基础)
- 理解 Linux 进程管理机制
- 熟悉 fork、exec、exit 等系统调用

## 涉及的文件

- `bpf/process.bpf.c` (新建 - 进程监控 eBPF 程序)
- `bpf/process.c` (新建 - 用户态加载器和 JSON 输出)
- `bpf/process_utils.h` (新建 - 工具函数头文件)
- `bpf/process_utils.c` (新建 - 工具函数实现)
- `bpf/test_process_utils.c` (新建 - 单元测试)
- `bpf/Makefile` (修改 - 添加构建规则)

## 实现步骤

### 1. 设计事件数据结构

#### 1.1 定义事件类型
- 进程启动事件(fork)
- 进程执行事件(exec)
- 进程退出事件(exit)
- 系统信息事件(system info)

#### 1.2 设计事件结构体
- 包含时间戳(使用 bpf_ktime_get_ns)
- 包含进程 ID、父进程 ID、线程组 ID
- 包含进程名称、命令行参数
- 包含用户 ID、组 ID
- 包含工作目录、环境变量等信息
- 考虑结构体大小限制和对齐

#### 1.3 设计输出格式
- 使用 JSON 格式输出便于解析
- 包含事件类型字段
- 包含所有相关元数据
- 时间戳使用纳秒精度

### 2. 实现 eBPF 内核态程序

#### 2.1 追踪进程创建
- 挂载到 sched_process_fork tracepoint
- 捕获父子进程信息
- 获取进程创建时间戳
- 通过 ring buffer 发送事件到用户态

#### 2.2 追踪进程执行
- 挂载到 sched_process_exec tracepoint
- 获取可执行文件路径
- 读取命令行参数(从 /proc/[pid]/cmdline 或 task_struct)
- 读取环境变量(需要考虑大小限制)
- 获取当前工作目录

#### 2.3 追踪进程退出
- 挂载到 sched_process_exit tracepoint
- 捕获退出状态码
- 记录进程运行时长
- 发送退出事件

#### 2.4 读取内核数据结构
- 使用 bpf_core_read 安全读取 task_struct 字段
- 读取进程凭证信息(uid, gid)
- 读取进程命名空间信息
- 处理指针链式访问

#### 2.5 实现辅助函数
- 字符串拷贝函数(处理内核字符串)
- 参数解析函数
- 路径解析函数
- 注意 eBPF 栈大小限制(512 字节)

### 3. 实现用户态加载器

#### 3.1 程序加载和挂载
- 使用 skeleton 加载 eBPF 程序
- 挂载到所有必需的 tracepoint
- 处理加载失败的情况
- 提供详细的错误信息

#### 3.2 命令行参数解析
- 支持按进程名过滤(-c 或 --comm 选项)
- 支持按进程 ID 过滤(-p 或 --pid 选项)
- 支持按二进制路径过滤(--binary-path 选项)
- 支持详细输出模式(-v 或 --verbose)

#### 3.3 配置 eBPF 程序
- 将过滤条件传递给 eBPF 程序
- 可以通过 eBPF maps 传递配置
- 或在用户态过滤

#### 3.4 处理事件输出
- 从 ring buffer 接收事件
- 解析事件结构体
- 格式化为 JSON 输出到 stdout
- 处理大量事件的情况,避免丢失

#### 3.5 JSON 输出格式化
- 实现 JSON 生成函数(不依赖第三方库)
- 正确转义特殊字符
- 包含所有事件字段
- 保持输出格式一致

### 4. 实现工具函数

#### 4.1 字符串处理
- JSON 字符串转义函数
- 路径规范化函数
- 字符串验证函数(检查 UTF-8)

#### 4.2 时间戳处理
- 启动时间获取(从 /proc/stat 读取系统启动时间)
- 将内核时间戳转换为 epoch 时间
- 格式化时间输出

#### 4.3 系统信息收集
- 读取系统信息(主机名、内核版本等)
- 定期输出系统信息事件
- 包含在 JSON 输出中

### 5. 实现单元测试

#### 5.1 测试工具函数
- 创建 test_process_utils.c
- 测试 JSON 转义函数
- 测试字符串处理函数
- 测试时间戳转换函数

#### 5.2 测试框架
- 使用简单的 assert 宏
- 打印测试结果
- 统计通过/失败的测试数量

#### 5.3 边界情况测试
- 空字符串处理
- 特殊字符处理
- 超长字符串处理
- NULL 指针处理

### 6. 构建系统集成

#### 6.1 更新 Makefile
- 添加 process 目标
- 添加测试目标(test-process)
- 支持 AddressSanitizer 构建(debug 模式)
- 处理依赖关系

#### 6.2 清理规则
- 添加清理中间文件的规则
- 清理生成的 skeleton 文件
- 清理测试可执行文件

## 验收标准

### 功能验收
1. eBPF 程序成功加载并挂载到所有 tracepoint
2. 能够捕获进程创建、执行、退出事件
3. 输出正确的 JSON 格式数据
4. 过滤功能正常工作(按名称、PID、路径)
5. 时间戳准确,可转换为真实时间
6. 程序稳定运行,不崩溃
7. 资源正确清理,无内存泄漏

### 数据质量
1. JSON 格式合法,可被标准解析器解析
2. 所有字段包含有效数据
3. 时间戳单调递增
4. 进程信息准确完整
5. 特殊字符正确转义

### 测试覆盖
1. 所有单元测试通过
2. 手动测试覆盖各种场景

## 测试方法

### 单元测试

#### 测试 1: 运行单元测试
```bash
cd bpf
make test
```
**预期结果**:
- 所有测试用例通过
- 无内存错误(如果使用 AddressSanitizer)
- 输出测试统计信息

### 手动测试

#### 测试 2: 编译程序
```bash
cd bpf
make process
```
**预期结果**:
- 编译成功,无警告
- 生成 process 可执行文件

#### 测试 3: 运行监控所有进程
```bash
sudo ./bpf/process
```
**预期结果**:
- 程序启动成功
- 输出 JSON 格式的事件流
- 每行是一个完整的 JSON 对象

#### 测试 4: 按名称过滤
```bash
sudo ./bpf/process -c bash
```
在另一个终端启动 bash:
```bash
bash
exit
```
**预期结果**:
- 只输出 bash 相关的事件
- 包含启动和退出事件
- 过滤准确,不输出其他进程

#### 测试 5: 按 PID 过滤
```bash
# 先获取一个进程的 PID
echo $$
sudo ./bpf/process -p <PID>
```
**预期结果**:
- 只输出指定 PID 相关的事件

#### 测试 6: JSON 格式验证
```bash
sudo ./bpf/process -c ls | head -n 10 > /tmp/process_events.json
```
使用 Python 验证:
```bash
python3 -c "import json; [json.loads(line) for line in open('/tmp/process_events.json')]"
```
**预期结果**:
- 所有 JSON 行都能成功解析
- 无语法错误

#### 测试 7: 压力测试
```bash
sudo ./bpf/process &
# 生成大量进程
for i in {1..100}; do ls /tmp > /dev/null; done
```
**预期结果**:
- 程序稳定运行,不崩溃
- 所有事件都被捕获并输出
- 无明显性能问题

#### 测试 8: 长时间运行
```bash
sudo ./bpf/process -c python &
# 运行一段时间后检查
sleep 600
# 检查进程还在运行
ps aux | grep process
```
**预期结果**:
- 程序持续运行,不退出
- 内存使用稳定,无泄漏

### 集成测试

#### 测试 9: 验证事件完整性
启动一个进程,确认捕获到完整的生命周期:
```bash
sudo ./bpf/process -c sleep > /tmp/sleep_events.json &
sleep 1
# 查看输出
cat /tmp/sleep_events.json
```
**预期结果**:
- 捕获到 exec 事件
- 捕获到 exit 事件
- 事件包含完整信息(进程名、参数、时间戳等)

## 常见问题和排查

### 问题 1: 无法读取命令行参数
**现象**: 参数字段为空或乱码
**排查**:
- 检查是否正确使用 bpf_core_read
- 检查指针是否有效
- 注意内核版本差异

### 问题 2: JSON 输出格式错误
**现象**: JSON 解析失败
**排查**:
- 检查特殊字符转义
- 检查引号配对
- 检查换行符处理

### 问题 3: 事件丢失
**现象**: 某些进程事件未捕获
**排查**:
- 检查 ring buffer 大小是否足够
- 检查是否有 buffer 满的日志
- 增大 ring buffer 大小

### 问题 4: 时间戳不准确
**现象**: 时间戳转换为真实时间不正确
**排查**:
- 检查系统启动时间读取
- 检查时间戳计算逻辑
- 使用 bpf_ktime_get_ns 而不是其他时间函数

### 问题 5: 内存泄漏
**现象**: 长时间运行后内存增长
**排查**:
- 使用 valgrind 或 AddressSanitizer 检查
- 确保所有分配的资源都被释放
- 检查 skeleton destroy 是否调用

### 问题 6: 性能影响大
**现象**: 系统变慢
**排查**:
- 减少捕获的信息量
- 优化 eBPF 程序逻辑
- 添加更严格的过滤条件

## 注意事项

1. **安全性**: 不要输出敏感信息(如密码、令牌等环境变量)
2. **性能**: eBPF 程序执行时间要短,避免阻塞系统
3. **兼容性**: 考虑不同内核版本的差异
4. **资源限制**: 注意 eBPF 栈大小限制,使用 per-cpu array 存储大数据
5. **错误处理**: 所有系统调用都要检查返回值

## 下一步

完成进程监控后,可以继续:
- **任务 04**: 实现 SSL/TLS 流量监控 eBPF 程序
- 学习 uprobe 和动态库函数追踪
